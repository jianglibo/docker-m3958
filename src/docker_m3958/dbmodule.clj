(ns docker-m3958.dbmodule
  (:require [clojure.java.io :as io])
  (:require [clojure.data.json :as json])
  (:require [clojure.string :as str])
  (:require [clojure.java.shell :as shell])
  (:require [clojure.java.jdbc :as j])
  (:import java.nio.file.Paths)
  (:import org.hsqldb.jdbc.JDBCDriver)
  (:import com.mchange.v2.c3p0.ComboPooledDataSource)
  (:gen-class))


;:table-spec "ENGINE=InnoDB"

(def id-field [:id "INTEGER GENERATED BY DEFAULT AS IDENTITY" :PRIMARY :KEY])

(def tds [(list :apptpl
                  id-field
                  [:name "VARCHAR(64)"]
                  [:desc "CLOB(1000)"])
          (list :app
                id-field
                [:name "VARCHAR(64)"]
                [:desc "CLOB(1000)"])
          (list :image
                id-field
                [:name "VARCHAR(64)"]
                [:desc "CLOB(1000)"]
                [:iname "VARCHAR(64)"])
          (list :apptpl_images
                [:apptpl_id "INTEGER"]
                [:image_id "INTEGER"])

          ])


(def db-filename (if (nil? (re-find #"(?i)windows" (System/getProperty "os.name")))
                  "/opt/db/hsqldb"
                  "c:/db/hsqldb"))


(io/make-parents db-filename)

(def db-spec
  {:classname "org.hsqldb.jdbc.JDBCDriver"
   :subprotocol "hsqldb"
   :subname (str "file:" db-filename)
   :user "aUserName"
   :password "3xLVz"})

(defn pool
  [spec]
  (let [cpds (doto (ComboPooledDataSource.)
               (.setDriverClass (:classname spec))
               (.setJdbcUrl (str "jdbc:" (:subprotocol spec) ":" (:subname spec)))
               (.setUser (:user spec))
               (.setPassword (:password spec))
               ;; expire excess connections after 30 minutes of inactivity:
               (.setMaxIdleTimeExcessConnections (* 30 60))
               ;; expire connections after 3 hours of inactivity:
               (.setMaxIdleTime (* 3 60 60)))]
    {:datasource cpds}))

(def pooled-db (delay (pool db-spec)))

(defn db-connection [] @pooled-db)

(defn db-meta []
  (j/with-db-metadata [md (db-connection)]
        (j/metadata-result (.getTables md nil nil nil (into-array ["TABLE"])))))

(defn table-meta [tablename]
  (j/with-db-metadata [md (db-connection)]
        (j/metadata-result (.getColumns md nil nil tablename nil))))
; :identifiers #(.replace % \_ \-)

(defn table-exist? [tablename]
  (some #(= (str/upper-case tablename) (str/upper-case %1))
    (map :table_name (db-meta))))

(defn column-exist? [tablename colname]
  (some #(= (str/upper-case tablename) (str/upper-case %1))
    (map :table_name (table-meta (str/upper-case (name colname))))))

(defn get-table-ddl [td]
  (apply j/create-table-ddl td))

;(get-table-ddl (first tds))

(defn init-tables []
  (for [td tds :let [tname (name (first td))]]
    (do
      (j/db-do-commands (db-connection)
                      (if-not (table-exist? tname)
                        (apply j/create-table-ddl td))))
      (let )
    )
  )

(#{(list 1 2 3)} (list 1 2 3))
;java -cp ../lib/hsqldb.jar org.hsqldb.util.DatabaseManager
(map :table_name (db-meta))
(map :column_name (table-meta (str/upper-case (name (first (first tds))))))
(init-tables)

(for [x (list 0 1 2 3 4 5)
             :let [y (* x 3)]
             :when (even? y)]
         y)
;(j/db-do-commands (db-connection) (j/drop-table-ddl :fruit))

;(let [[a b c & d :as e] [1 2 3 4 5 6 7]]
;  [a b c d e])
;
;(let [[[x1 y1][x2 y2]] [[1 2] [3 4]]]
;  [x1 y1 x2 y2])
;
;(let [[a b & c :as str] "asdjhhfdas"]
;  [a b c str])
;
;(let [{a :a, b :b, c :c, :as m :or {a 2 b 3}}  {:a 5 :c 6}]
;  [a b c m])


;(name :smb)
;(let [{:keys [table-spec entities] :or {table-spec "a" entities "b"}} {}]
;  [table-spec entities])
;
;(defn create-table-ddl
;  "Given a table name and column specs with an optional table-spec
;   return the DDL string for creating that table."
;  [table & specs]
;  (let [col-specs (take-while (fn [s]
;                                (not (or (= :table-spec s)
;                                         (= :entities s)))) specs)
;        other-specs (drop (count col-specs) specs)
;        {:keys [table-spec entities] :or {entities identity}} other-specs
;        table-spec-str (or (and table-spec (str " " table-spec)) "")
;        spec-to-string (fn [spec]
;                         (str/join " " (cons (as-sql-name entities (first spec))
;                                             (map name (rest spec)))))]
;    (format "CREATE TABLE %s (%s)%s"
;            (as-sql-name entities table)
;            (str/join ", " (map spec-to-string col-specs))
;            table-spec-str)))
